---
meta:
  title: Debug Driven Development
  description: Write Debuggable Code
  slug: debug-driven-development
headers:
  Cache-Control: max-age=60000
---

# Debug Driven Development

You've likely heard of Test Driven Development, or maybe Behavrioal Driven
Development. I have a new phrase: Debug Driven Development(â„¢).

## What is Debug Driven Development

Consider the following two code samples. Which would you rather face when
locating a bug or adding new business requirements. Which would you prefer to
leave for your future self or coworker.

```ts
// Option 1.
export const getNameFrequency = (myObj) => {
    return myObj["prop"].map(res => res.name).reduce((acc, curr) => {

        const value = acc[curr];

        return {
            ...acc,
            ...{
                [curr]: value !== undefined ?
                    value + 1 :
                    1;
            }
        };

    }};

// Option 2.
export const getNameFrequency = (myObj) => {

    const users = myObj["prop"]
    const userNames = users.map(res => res.name);
    const userNamesToFrequency = userNames.reduce((acc, curr) => {

        const value = acc[curr];
        const currentCount = value !== undefined ?
            value + 1 :
            1;

        const entry = {
            [curr]: currentCount
        };

        const updatedAccumulator = {
            ...acc,
            ...entry
        };

        return updatedAccumulator;

    });

    return userNamesToFrequency;
};
```
The first snippet is readable though I wouldn't call it simple. In both we get a
value out of an object that is an array of objects with a name property that we
extract and count the frequency of.

For any work in one of the snippets, you'll likely use some if not all of the
following:
* `console.log()`
* `debugger;`
* Breakpoints
* Tests

In each of those techniques inspecting the intermediate states of data
transformations is essential to narrow in on a bug or validate changes. Debug
Driven Development optimizes for debugging by writing code to provide
opportunities for these and any other techniques you use.

Hopefully you're building up an intuition for debug driven development.

## Leveraging Debug Driven Development

Debug Driven Development might sound similar to `KISS`: Keep It Simple Stupid.
The two are related, but Debug Driven Development goes further. Phrases like
KISS focus on readability whereas Debug Driven Development focuses on writing
code so that it is as easy to debug as possible.

This principle manifests most concretely by storing intermediate states of
computation in their own variables, avoiding complex logic in method calls, and
avoiding inlining function calls as the arguments to other functions:
`getName(getUserObjectFromDB(getDBConnection()))`.


Of the two snippets below, which would be easier to debug or modify? If you say
the snippet below, well, I'm thankful you're still reading.

```ts
const myArr = getArrayOfData();

const filteredResults = myArr.filter(entry => {
    entry !== null && entry !== undefined;
}).filter(entry => {
    entry.name.length > 5;
}).filter(entry => {
    entry.age > 21
});
```

```ts
const myArr = getArrayOfData();

const filteredResults = myArr.filter(entry => {
    entry !== null && entry !== undefined && entry.name.length > 5 && entry.age 21
});
```

You're probably bulking at how the first example loops through the array 3 times
(3 times!) instead of just once. Totally unnecessary and a performance hit. And
you're right. But it's still a lot more readable and easier to debug than the
second example. Both are easy to debug, but the second would require some
rewriting to inspect specific conditions or add in new ones. There is a middle
ground of course. We could write this as

```ts
const myArr = getArrayOfData();

const filteredResults = myArr.filter(entry => {
    const isNotEmpty = entry !== null && entry !== undefined
    const nameIsMoreThan5Characters = entry.name.length > 5
    const isOver21 = entry.age 21

    return isNotEmpty && nameIsMoreThan5Characters && isOver21;
});
```

And that would indeed be easy to debug! Another approach could be:

```ts
const isNotEmpty = entry => !== null && entry !== undefined
const nameIsMoreThan5Characters = entry => entry.name.length > 5
const isOver21 = entry => entry.age 21

const filterFunction = compose(isNotEmpty, nameIsMoreThan5Characters, isOver21);

const filteredResults = myArr.filter(filterFunction);
```

Depending on how comfortable you are with composition (or trying to reuse utility
functions), you may prefer one over the other but both qualify as code written
optimizing for debugability (they both are also easy to read as writing easy to
debug code necessitates writing readable code).

And that's Debug Driven Development

## Wrapping Up

Debug Driven Development is entirely compatible with other methodologies (like
TDD or BDD). Focusing on any of these will often include partly focusing on the
others. Debug Driven Development is just another technique to improve your
ability to be effective in writing code.
