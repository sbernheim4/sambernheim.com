---
meta:
  title: Debug Driven Development
  description: Write Debuggable Code
  slug: debug-driven-development
headers:
  Cache-Control: max-age=60000
---

# Debug Driven Development

You've likely heard of Test Driven Development, or maybe Behavrioal Driven
Development. I have a new phrase: Debug Driven Development(â„¢).

## What is Debug Driven Development

Consider the following two code samples. Which would you rather face when
locating a bug, adding new business requirements, and leaving for your
future self or coworker.

```ts
// Option 1.
export const getNameFrequency = (myObj) => {
    return myObj["prop"].map(res => res.name).reduce((acc, curr) => {

        const value = acc[curr];

        return {
            ...acc,
            ...{
                [curr]: value !== undefined ?
                    value + 1 :
                    1;
            }
        };

    }};

// Option 2.
export const getNameFrequency = (myObj) => {

    const users = myObj["prop"]
    const userNames = users.map(res => res.name);
    const userNamesToFrequency = userNames.reduce((acc, curr) => {

        const value = acc[curr];
        const currentCount = value !== undefined ?
            value + 1 :
            1;

        const entry = {
            [curr]: currentCount
        };

        const updatedAccumulator = {
            ...acc,
            ...entry
        };

        return updatedAccumulator;

    });

    return userNamesToFrequency;
};
```
The first snippet is readable though I wouldn't call it simple. In both we get a
value out of an object that is an array of objects with a name property that we
extract and count the frequency of.

For any work in one of the snippets, you'll likely use some if not all of the
following:
* `console.log()`
* `debugger;`
* Breakpoints
* Tests

In each of those techniques inspecting the intermediate states of data
transformations is essential to narrow in on a bug and validate changes.

Debug Driven Development optimizes for future debugging by provide lots of
opportunities for breakpoints, console logs, scratch work and whatever
other techniques you leverage when working in code.

Hopefully you're building up an intuition for debug driven development.

## How to Leverage Debug Driven Development

Debug Driven Development might sound similar to KISS: Keep It Simple Stupid.
The two are related, but Debug Driven Development takes it a bit further.
Phrases like KISS focus on readability whereas Debug Driven Development focuses
on writing code so that it is as easy to debug as possible in the future.

This principle manifests most concretely by storing intermediate states of
computation in their own variables, avoiding combining logic of chained method
calls, and inlining function calls as the arguments to other functions:
`getName(getUserObjectFromDB(getDBConnection()))`.

```ts
const myArr = getArrayOfData();

const filteredResults = myArr.filter(entry => {
    entry !== null && entry !== undefined;
}).filter(entry => {
    entry.name.length > 5;
}).filter(entry => {
    entry.age > 21
});
```

Is the snippet above or the one below easier to debug and modify. If you say the
snippet below, I'm thankful you're still reading.

```ts
const myArr = getArrayOfData();

const filteredResults = myArr.filter(entry => {
    entry !== null && entry !== undefined && entry.name.length > 5 && entry.age 21
});
```

You're probably bulking that the first example loops through the array 3 times
(3 times!) instead of just once. Totally unnecessary and a performance hit. And
you're right. But it's still a lot more readable and easier to debug than the
second. There is a middle ground of course. We could write the 2nd example as

```ts
const myArr = getArrayOfData();

const filteredResults = myArr.filter(entry => {
    const isNotEmpty = entry !== null && entry !== undefined
    const nameIsMoreThan5Characters = entry.name.length > 5
    const isOver21 = entry.age 21

    return isNotEmpty && nameIsMoreThan5Characters && isOver21;
});
```

And that would indeed be easy to debug! Another approach could be:

```ts
const isNotEmpty = entry => !== null && entry !== undefined
const nameIsMoreThan5Characters = entry => entry.name.length > 5
const isOver21 = entry => entry.age 21

const filterFunction = compose(isNotEmpty, nameIsMoreThan5Characters, isOver21);

const filteredResults = myArr.filter(filterFunction);
```

Depending on how comfortable you are with composition or trying to reuse utility
functions, you may prefer one over the other but both qualify as code written
optimizing for debugability (they both are also easy to read as writing easy to
debug code often requires writing readable code).

And that's Debug Driven Development

## Wrapping Up

Debug Driven Development is entirely compatible with other methodologies (like
TDD or BDD). Focusing on any of these will often include partly focusing on the
others. Debug Driven Development is just another technique to improve your
ability to be effective in writing code.
